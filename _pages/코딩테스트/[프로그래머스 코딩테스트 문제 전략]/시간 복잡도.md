---
title : "[프로그래머스 코딩 테스트 문제 풀이 전략 = 시간 복잡도]"
tags : 
    - python
    - coding test
date : "2024-07-26"
thumbnail : "/assets/img/thumbnail/python.jpg"
bookmark : true
---

# 시간 복잡도란

어떤 알고리즘이 더 나은지 비교할 수 있는 기준이 필요함. <br>
문제 해결에 필요한 입력값과 해결하는 프로그램이 주어졌을 때, 프로그램이 결과를 만들어내는데 걸리는 정도를 "복잡도"라고 한다. <br>

얼마나 오래 걸리는 지를 "시간 복잡도"라고 하고, <br>얼마나 많은 메모리를 사용하는 지를 "공간 복잡도"라고 한다. 


### Big-O 표기법

실제 코드를 실행하는 시간을 정확한 수치로 표현하기는 어렵지만, 문법이나 구성에서 발생하는 비용을 수치화해 문제를 푸는 데 필요한 총 연산의 수를 수학적으로 표현할 수 있다. <br>
이를 "점근 표기법"이라고 한다. <br>가장 흔하게 사용하는 표현은 최악의 경우를 계산하는 "Big-O 표기법" 이다. 

빅오 표기법은 '최악의 경우 이정도 시간이 걸린다'로 이해할 수 있다. 
$$모든 0 < n_0 <= n에 대하여 0<=f(n)<=cg(n)인\,양의\,상수\,c와\,n_0가\,존재하면 f(n) \in Og(n)이다. $$

빅오 표기법을 사용하면 실제 소요되는 시간의 최고 차항만 남는다. (상대적으로 작은 수는 무시할 수 있어 최고 차항 미만의 연산은 전체 소요 시간에 영항을 줄 수 없다.)


### 시간 복잡도 그래프
![JPA](/assets/img/codingtest/1.png "jpa")

- O(1) : 입력 데이터 수의 크기와 복잡도에 관계 없이 항상 상수를 가지는 알고리즘. 전체 시간 복잡도를 계산할 때 연산 횟수에 영향을 거의 받지 않음. 해시 테이블 삽입, 삭제, 검색 시에도 상수 시간을 보장한다. 

- O(logn) : 크기가 커질수록 처리 시간이 짧아지는 알고리즘. 데이터가 많아도 매우 짧은 시간에 끝남. ex) 이진탐색

- O(n) : 입력 데이터의 수에 비례하게 시간을 소모하는 알고리즘. 배열 탐색, 초기화, for문, 문자열 탐색, 데이터 재구축 등 입력 데이터를 다루는 동작 대부분이 해당.

- O(nlogn) : 입력 데이터 수에 비례해서 연산이 추가로 필요한 알고리즘. 대부분의 정렬이 이정도 시간이 소요됨. 

- O(n^2) : 입력 데이터 수의 제곱만큼 시간을 소모함. 이중 for문, 배열끼리 값 비교, 2차원 배열을 사용하면 이정도 시간이 소요됨.

- O(2^n) : 입력 데이터수가 적거나 특수한 조건에서만 사용하는 시간 복잡도. ex)피보나치 수

### 시간 복잡도 선택 참고 사항

1. 최대 시간이 1초일 때 입력 데이터 수에 따른 시간 복잡도.

- 1,000개 -> O(n^2)이하

- 10,000개 -> O(n^2)미만

- 100,000개 -> O(nlogn)이하

- 1,000,000개 -> O(nlogn)미만 (가급적 O(n)정도)

2. 자주 사용하는 자료 구조의 시간 복잡도 

|자료구조|탐색|삽입|삭제|
|---|---|---|---|
|배열|O(N)|O(n)|O(n)|
|정렬된 배열|O(logn)|O(n)|O(n)|
|연결 리스트|O(n)|O(1)|O(1)|
|스택/큐|O(n)|O(1)|O(1)|
|해시|O(1)|O(1)|O(1)|
|이진트리|O(logn)|O(logn)|O(logn)|


# 시간 복잡도 계산하기

### 내장 함수 시간 복잡도
#### 리스트 [ ]

|시간 복잡도|기능|사용 예|
|---|---|---|
|O(1)|조회|data[1]
||값 할당|data[1] = 1|
||길이 가져오기|len(data)|
||리스트 1개 추가|data.append(1)|
||마지막 리스트 1개 제거|data.pop()|
||리스트 초기화|data.clear()|
|O(n)|리스트 슬라이싱|data[a:b]|
||리스트+리스트|data.extend(data2)|
||리스트 할당|list(data)|
||리스트 비교|data == data2 / data != data2|
||값 범위 할당|data[a:b] = 3|
||특정 리스트 항목 제거|del data[1] / data.pop(1)|
||리스트에 값이 있는지 확인|1 in data|
||리스트 복사|data.copy()|
||최솟값, 최댓값 탐색|min(data), max(data)|
||리스트 역순|data.reverse()|
||리스트 전체 연산|for v in data:|
|O(nlogn)|리스트 정렬|data.sort() / sorted(data)|
|O(kn)|데이터 전체 반복|2*data|

#### 집합{ }

|시간 복잡도|기능|사용 예|
|---|---|---|
|O(1)|길이 가져오기|len(data)|
||요소 추가|data.add(5)|
||집합에 값이 있는지 확인|1 in data|
||값 제거|data.remove() / data.discard() / data.pop()|
||집합 초기화|data.clear()|
|O(n)|집합 할당|
||집합 검사|set(data)|
||집합 비교|data == data2 / data != data2|
||집합 연산|data & data2 / data - data2|
||집합 전체 연산|for v in data|
||집합 복사|data.copy()

#### 딕셔너리 {}

|시간 복잡도|기능|사용 예|
|---|---|---|
|O(1)|조회|data[1] / data.get(1,0)|
||값 할당|data[1] = 1|
||길이 가져오기|data[1] = 1|
||값 제거|del data[1] / data.pop(1) / data.popitem()|
||딕셔너리 초기화|data.clear()|
||딕셔너리 값 가져오기|data.keys()|
|O(n)|딕서너리 할당|dict(data)|
||딕셔너리 전체 연산|for i in data:|


### 시간 복잡도 줄이기

- readline()
    
    input()의 경우에는 데이터가 많을 수록 효율이 떨어진다. sys모듈의 readline()을 사용하면 받은 문자열을 다시 쪼개야 하지만, 빨리 읽고오는 편이 효율적이다. 
    ```
    import sys
    data = sys.stdin.readline()
    ```

- 리스트 곱셈

    리스트에 곱셈 연산을 하여 초기화와 할당을 동시에 진행하도록 할 수 있다. 
    ```
    data1 = [0 for _ in range(1000)]
    data2 = [0] * 1000
    ```

- 문자열 합치기

    문자열을 '+'로 합칠 경우에는 각 문자열을 새로운 메모리에 복사하여 새 문자열을 만들기 때문에 시간 복잡도가 O(n^2)정도가 된다. <br>
    ''.join()을 사용ㅎ 문자열을 합쳐야 이러한 계산 과정을 거치지 않고 빠르게 합칠 수 있다. 

- 조건문 연산 줄이기

    if 조건문에서 다중 조건을 사용할 때, 두 조건 중 빨리 실행되는 쪽을 앞에 배치하는 것이 유리하다. 

- 슬라이싱

    리스트, 튜플 같은 자료형에 범위를 정해 일부분을 추출하는 슬라이싱을 사용하면 코드를 절약할 수 있어 개발이 편리하다. 연속된 자료형이라면 어떤 것이라도 슬라이싱 할 수 있다. 

- 표준 라이브러리 활용

    자주 사용하는 표준 라이브러리
    
    - heapq : 이진 트리를 기반으로 하는 최소 힙 자료구조. 항상 정렬된 상태로 값의 추가/삭제가 이루어진다. 우선 순위 큐, 최단 거리 알고리즘 구현시 사용됨. 

    - collections : 연속되는 자료를 가지고 있는 자료형에서 동인한 원소가 몇 개 있는지 확인 가능한 counter 존재. 덱 자료구조를 구현하는 deque도 존재

    - itertools : 경우의 수 문제에 사용. 순열(permutations), 조합(combinations), 중복 순열(permutations_with_replacement), 중복 순열(combinations_with_replacement)등에 사용

    - math : 최대공약수, 최소 공배구, 팩토리얼...등 존재

    - bisect : 이진 탐색 기능 제공. 정렬된 데이터가 필요하며, 특정 범위안에 원소가 있는지 검사하거나 몇개 존재하는지 확인 가능


### 리스트 컴프리헨션, 제너레이터
```
data = []
for i in range(1,11):
    data.append(i)

# 컴프리헨션 사용
data = [i for i in range(1,11)]
```

tuple, set, dict와 같은 자료형에도 모두 사용 가능
<br>
컴프리헨션은 편리하지만, 공간 복잡도가 커지는 경우가 많다. 이에 대한 대응책으로 제네레이터를 사용한다. 
<br>
함수를 사용할 때 return 대신 yield를 사용하거나, 컴프리헨션 문구를 소괄호로 감싸주는 방식으로 표현식을 생성한다. 
```
(i for i in range(1,11))
```

